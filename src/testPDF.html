<html>
    <head>
        <script src="https://npmcdn.com/pdfjs-dist/build/pdf.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    </head>
    Input class name (i.e. CS225)
    <input id="classname" name = "classname" type="string"/>
    <br>
    <body>
        <input id="pdffile" name="pdffile" type="file" />
        <button id="btn" onclick="convert()">Process</button>
        <div id="result"></div>
    </body>
</html>


<script>
    // import pdfjsLib from 'pdfjs-dist';
    // document.getElementById('btn').addEventListener('click', convert);
    const setWords = new Set();

    function isNumber(char) {
        return /^\d$/.test(char);
    }

    function convert() {
        var fr=new FileReader();
        var pdff = new Pdf2TextClass();
        //why do we NEED the fr.onload function to run the inner bit of code?
        fr.onload=function(){
            //output is stored in result
            pdff.pdfToText(fr.result, null, (text) => { document.getElementById('result').innerText += text; });
        }
        //why doesn't the order matter?
        fr.readAsDataURL(document.getElementById('pdffile').files[0])

        console.log(document.getElementById('result').innerText)
        let outstring = "";
        for (let i = 0; i < document.getElementById('result').innerText.length; i++) {
            if (!isNumber(document.getElementById('result').innerText[i])) {
                outstring += document.getElementById('result').innerText[i]
            } else {
                //console.log(outstring)
                if (outstring.length > 2) {
                    setWords.add(outstring.trim())
                }
                outstring = "";
            }
        }
        console.log(setWords)
        createTxtFile(setWords)
    }

    function Pdf2TextClass() {
        var self = this;
        this.complete = 0;

        this.pdfToText = function (data, callbackPageDone, callbackAllDone) {
            console.assert(data instanceof ArrayBuffer || typeof data == 'string');
            var loadingTask = pdfjsLib.getDocument(data);
            loadingTask.promise.then(function (pdf) {


                var total = pdf._pdfInfo.numPages;
                //callbackPageDone( 0, total );        
                var layers = {};
                for (i = 1; i <= total; i++) {
                    pdf.getPage(i).then(function (page) {
                        var n = page.pageNumber;
                        page.getTextContent().then(function (textContent) {

                            //console.log(textContent.items[0]);0
                            if (null != textContent.items) {
                                var page_text = "";
                                var last_block = null;
                                for (var k = 0; k < textContent.items.length; k++) {
                                    var block = textContent.items[k];
                                    if (last_block != null && last_block.str[last_block.str.length - 1] != ' ') {
                                        if (block.x < last_block.x)
                                            page_text += "\r\n";
                                        else if (last_block.y != block.y && (last_block.str.match(/^(\s?[a-zA-Z])$|^(.+\s[a-zA-Z])$/) == null))
                                            page_text += ' ';
                                    }
                                    page_text += block.str;
                                    last_block = block;
                                }

                                textContent != null && console.log("page " + n + " finished."); //" content: \n" + page_text);
                                layers[n] = page_text + "\n";
                            }
                            ++self.complete;
                            //callbackPageDone( self.complete, total );
                            if (self.complete == total) {
                                window.setTimeout(function () {
                                    var full_text = "";
                                    var num_pages = Object.keys(layers).length;
                                    for (var j = 1; j <= num_pages; j++)
                                        full_text += layers[j];
                                    callbackAllDone(full_text);
                                }, 1000);
                            }
                        }); // end  of page.getTextContent().then
                    }); // end of page.then
                } // of for
            });
        }; // end of pdfToText()
    }; // end of class

    function createTxtFile(text) {
        var className = document.getElementById("classname").value;
        var blob = new Blob([text],
                { type: "text/plain;charset=utf-8" });
                saveAs(blob, className + ".txt");
    }
    
    async function uploadFile(filePath, repo, owner, branch, token) {
        
        // Read the contents of the file
        const content = fs.readFileSync(filePath, "utf-8");
        
        // Encode the contents of the file as a base64 string
        // const encodedContent = Buffer.from(content).toString("base64");

        // Get the SHA of the latest commit on the branch
        const latestCommitResponse = await axios.get(
            `https://api.github.com/repos/${owner}/${repo}/git/refs/heads/${branch}`,
            { headers: { Authorization: `Token ${token}` } }
        );
        const latestCommitSha = latestCommitResponse.data.object.sha;

        // Create a new tree with the file
        const newTreeResponse = await axios.post(
            `https://api.github.com/repos/${owner}/${repo}/git/trees`,
            {
            base_tree: latestCommitSha,
            tree: [
                {
                path: filePath,
                mode: "100644",
                type: "blob",
                content: content
                }
            ]
            },
            { headers: { Authorization: `Token ${token}` } }
        );
        const newTreeSha = newTreeResponse.data.sha;

        // Create a new commit with the new tree
        const newCommitResponse = await axios.post(
            `https://api.github.com/repos/${owner}/${repo}/git/commits`,
            {
            message: "Add file",
            tree: newTreeSha,
            parents: [latestCommitSha]
            },
            { headers: { Authorization: `Token ${token}` } }
        );
        const newCommitSha = newCommitResponse.data.sha;

        // Update the branch to point to the new commit
        await axios.patch(
            `https://api.github.com/repos/${owner}/${repo}/git/refs/heads/${branch}`,
            { sha: newCommitSha },
            { headers: { Authorization: `Token ${token}` } }
        );
    }

    // uploadFile(
    // "Ayan.txt",
    // "Tester",
    // "highheat4",
    // "main",
    // "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"
    // );

</script>